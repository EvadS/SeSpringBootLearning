#Many-to-one and one-to-many

## пример 1

Гражданин имеет один основной адрес проживания, но по одному адресу могут проживать несколько человек
---
Владельцем в этом примере также будет класс **Person**, который имеет поле address, связанное с соответствующим объектом.
Поскольку адрес у гражданина только один, то используется аннотация **@ManyToOne**. Аннотацией **@JoinColumn**
определяется поле связи в таблице БД.

Поскольку _по одному адресу может проживать несколько жильцов_, то поле tenants представлено коллекцией, которая имеет
аннотацию **@OneToMany**. Параметр mappedBy также указывает на поле в классе владельца. Параметр 
```fetch=FetchType.EAGER ````говорит о том, что при загрузке владеемого объекта необходимо сразу загрузить и 
коллекцию владельцев.

## пример 2 
TODO: один post много comment 
### Однонаправленная связь 
самый простой вариант для создания связи   **@ManyToOne** на child стороне
это поле будет содержать foreign key
Использование:
Создаем **родитель** **-->** **сохраняем**, 
Создаем **child** указываем кто родитель -> **сохраняем** 

### Двонапраленная связь 
Один Parent - много Child 
**@JoinColumn** описана колонка в базе данных, которая связывает child с родительской таблицей
**mappedBy** указано свойство дочернего класса, которое связывает его с родительским
**CascadeType.ALL** все операции изменения в коллекции (добавление/изменение) отражает в базе данных
**orphanRemoval=true** указывает, что при удалении элемента из коллекции, нужно удалить элемент в базе данны
**FetchType.LAZY** — ленивая выборка. Элементы коллекции будут выбираться из базы данных только при обращении к какому-либо свойству коллекции.
В этом случае убрано каскадирование  
---

Если мы используем каскадирование 

---
Создаем **родительскую** сущность и через **проперти** заполняем (добавляем) **дочерние** 
при сохранении родителя все дочернее сохранятся
в зависимости от типа каскадирования удаление производится также
удалили роителя - дочерние тоже удалятся 

```java    Parent parent = new Parent();
    parent.setName("Parent 1 ");

    Child child = new Child();
    child.setChildName("child name 1.");
    parent.addChild(child);

    Child child2 = new Child();
    child2.setChildName("child name 1.");
    parent.addChild(child2);

    parentRepository.save(parent);

```
будут созданы записи для 1 - го родителя и 2-дочерних

**Замечания** 

в Parent 2 метода добавить в коллекцию дочерних и  убрать 
используется при каскадировании 
в дочерних поле парент_ид , будет заполнено значением  родителя к которому мы просоеденили

---

ручной режим 

--- 
Создаем родителя и сохраняем 
создаем дочернюю сущность и в поле родитель указываем ссылку на класс родителя -> сохраняем 

При удалении (поле с foreign key должно поддерживать nullable )
1. убираем ссылку на родителя 

```java
child.setParent(null);
childRepository.save(child);
```
2. удаляем.
     
      






